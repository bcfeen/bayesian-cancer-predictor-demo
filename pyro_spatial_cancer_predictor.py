# -*- coding: utf-8 -*-
"""pyro-spatial-cancer-predictor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DXOwWXww6O5sjdRt_QBYIj72zeCf-QMU
"""

!pip install scanpy pyro-ppl --quiet

import scanpy as sc

adata = sc.datasets.visium_sge(sample_id="V1_Breast_Cancer_Block_A_Section_1")

print(adata.shape)
adata.obs.head()

adata.obs.columns

adata.obs["cancer_label"] = (
    (adata.obs["array_row"] < 35) & (adata.obs["array_col"] < 50)
).astype(int)

adata.obs["cancer_label"].value_counts()

adata.X = adata.X.toarray()

adata.X = np.nan_to_num(adata.X, nan=0.0, posinf=0.0, neginf=0.0)

adata.var["mean_expression"] = adata.X.mean(axis=0)
print("Has +inf:", np.isposinf(adata.var["mean_expression"]).any())
print("Has -inf:", np.isneginf(adata.var["mean_expression"]).any())
print("Has NaN:", np.isnan(adata.var["mean_expression"]).any())

# Step 1: compute variance for each gene
gene_variances = np.var(adata.X, axis=0)

# Step 2: get indices of top 1000 most variable genes
top_idx = np.argsort(gene_variances)[-1000:]

# Step 3: subset adata to those genes
adata = adata[:, top_idx]

adata.shape

import torch

X = torch.tensor(adata.X, dtype=torch.float32)
y = torch.tensor(adata.obs["cancer_label"].values, dtype=torch.float32)

print(X.shape)
print(y.shape)
print(y[:5])

import pyro
import pyro.distributions as dist

def bayes_logistic_regression(X, y=None):
    n_features = X.shape[1]

    # Prior over weights and bias
    weights = pyro.sample("weights", dist.Normal(0., 1.).expand([n_features]).to_event(1))
    bias = pyro.sample("bias", dist.Normal(0., 1.))

    # Logistic regression
    logits = (X @ weights) + bias
    with pyro.plate("data", X.shape[0]):
        pyro.sample("obs", dist.Bernoulli(logits=logits), obs=y)

from pyro.infer import MCMC, NUTS

# Set up the NUTS sampler
nuts_kernel = NUTS(bayes_logistic_regression)

# MCMC config: 1000 posterior samples, 200 warmup steps
mcmc = MCMC(nuts_kernel, num_samples=1000, warmup_steps=200)
mcmc.run(X, y)

posterior_samples = mcmc.get_samples()
weights_samples = posterior_samples["weights"]  # shape: (1000 samples, 1000 genes)
bias_samples = posterior_samples["bias"]

import matplotlib.pyplot as plt

# Compute mean weight per gene
mean_weights = weights_samples.mean(dim=0)

# Get top 5 most positive weights (strongest cancer correlation)
top_gene_idxs = torch.topk(mean_weights, 5).indices

# Plot weight distribution for each
plt.figure(figsize=(12, 6))
for i, idx in enumerate(top_gene_idxs):
    plt.subplot(1, 5, i+1)
    plt.hist(weights_samples[:, idx].numpy(), bins=30, color="skyblue")
    plt.title(f"Gene {idx.item()}")
    plt.xlabel("Weight")
    plt.ylabel("Freq")
plt.tight_layout()
plt.show()

mean_preds.shape, std_preds.shape

import matplotlib.pyplot as plt

plt.figure(figsize=(8, 6))
plt.scatter(std_preds, mean_preds, alpha=0.3)
plt.xlabel("Prediction Uncertainty (Std Dev)")
plt.ylabel("Predicted Cancer Probability")
plt.title("Bayesian Predictions with Uncertainty")
plt.grid(True)
plt.show()

adata.obs["bayes_mean_pred"] = mean_preds
adata.obs["bayes_uncertainty"] = std_preds

sc.pl.spatial(
    adata,
    color="bayes_mean_pred",
    cmap="Reds",
    size=1.5,
    title="Predicted Cancer Probability (Bayesian)",
)

import pandas as pd

# Get mean and std of each geneâ€™s posterior weight
mean_w = weights_samples.mean(dim=0).numpy()
std_w = weights_samples.std(dim=0).numpy()

# Sort by highest mean weight (most predictive of cancer)
top_idx = mean_w.argsort()[::-1][:10]

# Build summary table
df = pd.DataFrame({
    "Gene Index": top_idx,
    "Mean Weight": mean_w[top_idx],
    "Weight Std Dev": std_w[top_idx]
})
df

# @title Gene Index vs Mean Weight

from matplotlib import pyplot as plt
df.plot(kind='scatter', x='Gene Index', y='Mean Weight', s=32, alpha=.8)
plt.gca().spines[['top', 'right',]].set_visible(False)